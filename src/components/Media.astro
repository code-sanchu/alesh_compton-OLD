---
import { Image } from "@astrojs/image/components";
import { getYoutubeVideoIdFromUrl } from "../helpers/youtube";
import type { LocalImage, YoutubeVideo } from "../types";
import YoutubeIframe from "./YoutubeIframe.astro";

type Props = { media: (LocalImage | YoutubeVideo)[] };

const { media } = Astro.props;
// IMPROVEMENTS:
// - image partially in view -> expanded doesn't look great because section of it not in view blinks in.
// - pre-load next image (images are lazy loaded by default)
// - background click to close
---

<div id="images-container" class="images-container">
  {
    media.map((item) =>
      item.type === "image" ? (
        <Image class="media image" src={item.url} alt="" format="avif" />
      ) : (
        <div class="media iframe-container">
          <YoutubeIframe
            id={(function () {
              const youtubeId = getYoutubeVideoIdFromUrl(item.youtubeUrl);

              return youtubeId!;
            })()}
          />
        </div>
      )
    )
  }
  <div class="images-spacer">helloo</div>
  <div id="background" class="background"></div>
</div>

<style>
  .images-container {
    /* border: 1px solid red; */
    position: relative;
    display: flex;
    align-items: flex-start;
    gap: 1vw;
    overflow-x: auto;
    padding-bottom: 0.5em;
  }
  .images-container::-webkit-scrollbar {
    height: 6px;
  }
  .images-container::-webkit-scrollbar-track {
    background: rgb(249, 250, 251);
    border-radius: 5px;
  }
  .images-container::-webkit-scrollbar-thumb {
    background: rgb(209 213 219);
    border-radius: 5px;
    width: 40px;
  }
  .images-container::-webkit-scrollbar-thumb:hover {
    background: rgb(156 163 175);
  }
  .images-spacer {
    color: white;
  }
  .image {
    max-height: 100%;
  }
  .media {
    width: auto;
    cursor: pointer;
    /* transition: transform ease-in-out 0.5s; */
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s;
  }
  .iframe-container {
    width: auto;
    height: 100%;
    max-height: 1000px;
  }
  .background {
    z-index: -1;
    position: fixed;
    inset: 0;
    background-color: white;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23000000' fill-opacity='1' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
    transition: opacity ease-in-out 0.5s;
    opacity: 0;
  }
</style>

<script>
  // HELPERS ______________________
  const calculateMediaTransform = (
    media: HTMLElement
  ): { scale: number; translate: { x: number; y: number } } => {
    const pageWidth = document.body.scrollWidth;
    const pageHeight = document.body.scrollHeight;

    const mediaInitialBounds = media.getBoundingClientRect();
    const initialWidth = mediaInitialBounds.width;
    const initialHeight = mediaInitialBounds.height;
    const initialLeft = mediaInitialBounds.left;
    const initialTop = mediaInitialBounds.top;

    const imageOrientation: "landscape" | "portrait" =
      initialWidth > initialHeight ? "landscape" : "portrait";

    const scale: number =
      imageOrientation === "landscape"
        ? (pageWidth * 0.95) / initialWidth
        : (pageHeight * 0.95) / initialHeight;

    const scaledWidth = initialWidth * scale;
    const scaledHeight = initialHeight * scale;

    const scaledYTopChange = (scaledHeight - initialHeight) / 2;
    const scaledYPos = initialTop - scaledYTopChange;
    const yDestination = (pageHeight - scaledHeight) / 2;
    const translateY = yDestination - scaledYPos;

    let translateX: number;

    const imageInitialCenterLeft = initialLeft + initialWidth / 2;
    const pageCenterLeft = pageWidth / 2;
    const transformDirection: "left" | "right" =
      imageInitialCenterLeft < pageCenterLeft ? "right" : "left";
    const leftDestination = (pageWidth - scaledWidth) / 2;

    if (transformDirection === "right") {
      media.style.transformOrigin = "left";
      translateX = leftDestination - initialLeft;
    } else {
      media.style.transformOrigin = "right";
      const scaledWidthChange = scaledWidth - initialWidth;
      const imageLeftAfterScale = initialLeft - scaledWidthChange;
      translateX = leftDestination - imageLeftAfterScale;
    }

    return { scale, translate: { x: translateX, y: translateY } };
  };

  const handleShrinkMediaElement = (
    mediaElement: HTMLElement,
    index: number,
    mediaElementsContainer: HTMLElement,
    mediaElements: HTMLElement[],
    background: HTMLElement,
    expandClass: string
  ) => {
    mediaElement.classList.remove(expandClass);

    mediaElement.style.transform = "translate(0px) scale(1)";

    background.style.opacity = "0";

    setTimeout(() => {
      mediaElementsContainer.style.overflowX = "auto";

      mediaElement.style.position = "static";
      mediaElement.style.zIndex = "0";

      for (let j = 0; j < mediaElements.length; j++) {
        const mediaElement = mediaElements[j];
        if (j === index) {
          continue;
        }

        mediaElement.style.opacity = "1";
      }

      background.style.zIndex = "-1";
    }, 550);
  };

  // ELEMENTS ______________________
  const mediaElementsContainer = document.getElementById("images-container");
  const mediaElements = Array.from(
    document.getElementsByClassName(
      "media"
    ) as HTMLCollectionOf<HTMLImageElement>
  );
  const background = document.getElementById("background");

  //
  const expandClass = "expand";

  //
  for (let i = 0; i < mediaElements.length; i++) {
    const mediaElement = mediaElements[i];

    if (mediaElementsContainer && mediaElement && background) {
      mediaElement.addEventListener("click", () => {
        const classList = mediaElement.classList;
        const isExpanded = classList.contains(expandClass);
        if (isExpanded) {
          handleShrinkMediaElement(
            mediaElement,
            i,
            mediaElementsContainer,
            mediaElements,
            background,
            expandClass
          );
        } else {
          mediaElement.classList.add(expandClass);

          for (let j = 0; j < mediaElements.length; j++) {
            const image = mediaElements[j];
            if (j === i) {
              continue;
            }

            image.style.opacity = "0"; // 0.2s
            image.style.transitionDuration = "100";
          }

          const { scale, translate } = calculateMediaTransform(mediaElement);

          mediaElement.style.zIndex = "3";
          mediaElement.style.left = `${
            mediaElement.getBoundingClientRect().left
          }px`;
          mediaElement.style.top = `${
            mediaElement.getBoundingClientRect().top
          }px`;
          mediaElement.style.width = `${
            mediaElement.getBoundingClientRect().width
          }px`;
          mediaElement.style.height = `${
            mediaElement.getBoundingClientRect().height
          }px`;

          // time for other images to fade out
          setTimeout(() => {
            mediaElementsContainer.style.overflowX = "visible";
            mediaElement.style.position = "fixed";

            mediaElement.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;

            background.style.zIndex = "2";
            background.style.opacity = "1";
          }, 150);
        }
      });
    }
  }
</script>

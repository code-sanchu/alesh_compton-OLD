---
import { Image } from "@astrojs/image/components";
import {
  getYoutubeEmbedUrlFromId,
  getYoutubeVideoIdFromUrl,
} from "../helpers/youtube";
import type { LocalImage, YoutubeVideo } from "../types";
import YoutubeIframe from "./YoutubeIframe.astro";

type Props = { media: (LocalImage | YoutubeVideo)[] };

const { media } = Astro.props;
// TODO: check responsiveness;
// IMPROVEMENTS:
// - image partially in view -> expanded doesn't look great because section of it not in view blinks in.
// - pre-load next image (images are lazy loaded by default)
// - background click to close
// const youtubeUrl = "https://www.youtube.com/watch?v=t6Lj6hzrmtE&t=1s";
// const youtubeId = getYoutubeVideoIdFromUrl(youtubeUrl);
// const youtubeEmbedUrl = getYoutubeEmbedUrlFromId(youtubeId!);
---

<div id="images-container" class="images-container">
  {
    media.map((item) =>
      item.type === "image" ? (
        <Image class="image" src={item.url} alt="" format="avif" />
      ) : (
        <div class="iframe-container">
          <YoutubeIframe
            id={(function () {
              const youtubeId = getYoutubeVideoIdFromUrl(item.youtubeUrl);

              return youtubeId!;
            })()}
          />
        </div>
      )
    )
  }
  <div class="images-spacer">helloo</div>
  <div id="background" class="background"></div>
</div>

<style>
  .iframe-container {
    width: auto;
    height: 100%;
    max-height: 1000px;
    /* border: 2px solid blue; */
  }
  .images-container {
    /* border: 1px solid red; */
    position: relative;
    display: flex;
    align-items: flex-start;
    gap: 1vw;
    overflow-x: auto;
    padding-bottom: 0.5em;
  }
  .images-container::-webkit-scrollbar {
    height: 6px;
  }
  .images-container::-webkit-scrollbar-track {
    background: rgb(249, 250, 251);
    border-radius: 5px;
  }
  .images-container::-webkit-scrollbar-thumb {
    background: rgb(209 213 219);
    border-radius: 5px;
    width: 40px;
  }
  .images-container::-webkit-scrollbar-thumb:hover {
    background: rgb(156 163 175);
  }
  .images-spacer {
    color: white;
  }
  .image {
    width: auto;
    max-height: 100%;
    cursor: pointer;
    /* transition: transform ease-in-out 0.5s; */
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s;
  }
  .background {
    z-index: -1;
    position: fixed;
    inset: 0;
    background-color: white;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23000000' fill-opacity='1' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
    transition: opacity ease-in-out 0.5s;
    opacity: 0;
  }
</style>

<script>
  // HELPERS ______________________
  const calculateImageTransform = (
    image: HTMLImageElement
  ): { scale: number; translate: { x: number; y: number } } => {
    const pageWidth = document.body.scrollWidth;
    const pageHeight = document.body.scrollHeight;

    const initialImageWidth = image.getBoundingClientRect().width;
    const initialImageHeight = image.getBoundingClientRect().height;

    const initialImageLeft = image.getBoundingClientRect().left;

    const imageOrientation: "landscape" | "portrait" =
      initialImageWidth > initialImageHeight ? "landscape" : "portrait";

    const scale: number =
      imageOrientation === "landscape"
        ? (pageWidth * 0.95) / initialImageWidth
        : (pageHeight * 0.95) / initialImageHeight;

    const scaledWidth = initialImageWidth * scale;
    const scaledHeight = initialImageHeight * scale;

    const initialYTop = image.getBoundingClientRect().top;
    const scaledYTopChange = (scaledHeight - initialImageHeight) / 2;
    const scaledYPos = initialYTop - scaledYTopChange;
    const yDestination = (pageHeight - scaledHeight) / 2;
    const translateY = yDestination - scaledYPos;

    let translateX: number;

    const imageInitialCenterLeft = initialImageLeft + initialImageWidth / 2;
    const pageCenterLeft = pageWidth / 2;
    const transformDirection: "left" | "right" =
      imageInitialCenterLeft < pageCenterLeft ? "right" : "left";
    const leftDestination = (pageWidth - scaledWidth) / 2;

    if (transformDirection === "right") {
      image.style.transformOrigin = "left";
      translateX = leftDestination - initialImageLeft;
    } else {
      image.style.transformOrigin = "right";
      const scaledWidthChange = scaledWidth - initialImageWidth;
      const imageLeftAfterScale = initialImageLeft - scaledWidthChange;
      translateX = leftDestination - imageLeftAfterScale;
    }

    return { scale, translate: { x: translateX, y: translateY } };
  };

  const handleContractImage = (
    image: HTMLImageElement,
    imageIndex: number,
    imagesContainer: HTMLElement,
    background: HTMLElement,
    expandClass: string
  ) => {
    image.classList.remove(expandClass);

    image.style.transform = "translate(0px) scale(1)";

    background.style.opacity = "0";

    setTimeout(() => {
      imagesContainer.style.overflowX = "auto";

      image.style.position = "static";
      image.style.zIndex = "0";

      for (let j = 0; j < images.length; j++) {
        const image = images[j];
        if (j === imageIndex) {
          continue;
        }

        image.style.opacity = "1";
      }

      background.style.zIndex = "-1";
    }, 550);
  };

  // ELEMENTS ______________________
  const images = Array.from(
    document.getElementsByClassName(
      "image"
    ) as HTMLCollectionOf<HTMLImageElement>
  );
  const background = document.getElementById("background");
  const imagesContainer = document.getElementById("images-container");

  //
  const expandClass = "expand";

  //
  for (let i = 0; i < images.length; i++) {
    const image = images[i];

    if (imagesContainer && image && background) {
      image.addEventListener("click", () => {
        const classList = image.classList;
        const isExpanded = classList.contains(expandClass);
        if (isExpanded) {
          handleContractImage(
            image,
            i,
            imagesContainer,
            background,
            expandClass
          );
        } else {
          image.classList.add(expandClass);

          for (let j = 0; j < images.length; j++) {
            const image = images[j];
            if (j === i) {
              continue;
            }

            image.style.opacity = "0"; // 0.2s
            image.style.transitionDuration = "100";
          }

          const { scale, translate } = calculateImageTransform(image);

          image.style.zIndex = "3";
          image.style.left = `${image.getBoundingClientRect().left}px`;
          image.style.top = `${image.getBoundingClientRect().top}px`;
          image.style.width = `${image.getBoundingClientRect().width}px`;
          image.style.height = `${image.getBoundingClientRect().height}px`;

          // time for other images to fade out
          setTimeout(() => {
            imagesContainer.style.overflowX = "visible";
            image.style.position = "fixed";

            image.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;

            background.style.zIndex = "2";
            background.style.opacity = "1";
          }, 150);
        }
      });
    }
  }
</script>

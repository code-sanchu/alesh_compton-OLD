---
import { getYoutubeVideoIdFromUrl } from "../helpers/youtube";
import type { LocalImage, YoutubeVideo } from "../types";
import MyImage from "./MyImage.astro";
import YoutubeIframe from "./YoutubeIframe.astro";

type Props = { media: (LocalImage | YoutubeVideo)[] };

const { media } = Astro.props;

// NOTES
// - in script below, in order to remove width set by `Picture`, removed auto
---

<div id="media-container" class="media-container">
  {
    media.map((item) =>
      item.type === "image" ? (
        <div class="media image">
          <MyImage src={item.url} type="image-img" />
        </div>
      ) : (
        <div class="media iframe-outer-container">
          <YoutubeIframe
            id={(function () {
              const youtubeId = getYoutubeVideoIdFromUrl(item.youtubeUrl);

              return youtubeId!;
            })()}
            coverImage={item.coverImage}
          />
        </div>
      )
    )
  }
  <div class="media-spacer">helloo</div>
  <div id="background" class="background"></div>
</div>

<style is:global>
  .media-container {
    position: relative;
    display: flex;
    align-items: flex-start;
    gap: 1vw;
    overflow-x: auto;
    overflow-y: hidden;
    padding-bottom: 0.5em;
    /* border: 1px solid red; */
  }
  .media-container::-webkit-scrollbar {
    height: 6px;
  }
  .media-container::-webkit-scrollbar-track {
    background: rgb(249, 250, 251);
    border-radius: 5px;
  }
  .media-container::-webkit-scrollbar-thumb {
    background: rgb(209 213 219);
    border-radius: 5px;
    width: 40px;
  }
  .media-container::-webkit-scrollbar-thumb:hover {
    background: rgb(156 163 175);
  }
  .media-spacer {
    color: white;
  }
  .media {
    width: auto;
    cursor: pointer;
    transition: transform ease-in-out 0.5s, opacity ease-in-out 0.2s;
  }
  .image {
    max-height: 100%;
  }
  .iframe-outer-container {
    width: auto;
    height: 100%;
    max-height: 1000px;
  }
  .background {
    z-index: -1;
    position: fixed;
    left: 0;
    top: 0;
    inset: 0;
    background-color: white;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23000000' fill-opacity='1' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
    transition: opacity ease-in-out 0.5s;
    opacity: 0;
  }
  @media screen and (max-width: 900px) {
    .media-container {
      height: 60vh;
    }
  }
</style>

<script>
  // MEDIA CONTAINER HORIZONTAL SCROLL_________________
  function SmoothScroll(target: HTMLElement, speed: number, smooth: number) {
    let moving = false;
    let pos = target.scrollLeft;
    let frame = target;

    target.addEventListener("mousewheel", scrolled, { passive: false });
    target.addEventListener("DOMMouseScroll", scrolled, { passive: false });

    function scrolled(e: { preventDefault: () => void }) {
      e.preventDefault(); // disable default scrolling

      var delta = normalizeWheelDelta(e);

      pos += -delta * speed;
      pos = Math.max(0, Math.min(pos, target.scrollWidth - frame.clientWidth)); // limit scrolling

      if (!moving) update();

      // HANDLE PRELOAD NEXT MEDIA
      const images = document.querySelectorAll(
        "img.original-size-img, img.iframe-img"
      ) as unknown as HTMLCollectionOf<HTMLImageElement>;
      for (let i = 0; i < images.length; i++) {
        const image = images[i];
        const rect = image.getBoundingClientRect();

        const isNearViewport = rect.left - rect.width < window.innerWidth;

        if (isNearViewport) {
          if (image.loading === "lazy") {
            image.loading = "eager";
          }
        }
      }
    }

    function normalizeWheelDelta(e: {
      preventDefault?: () => void;
      detail?: any;
      wheelDelta?: any;
    }) {
      if (e.detail) {
        if (e.wheelDelta)
          return (e.wheelDelta / e.detail / 40) * (e.detail > 0 ? 1 : -1);
        // Opera
        else return -e.detail / 3; // Firefox
      } else return e.wheelDelta / 120; // IE,Safari,Chrome
    }

    function update() {
      moving = true;

      var delta = (pos - target.scrollLeft) / smooth;

      target.scrollLeft += delta;

      if (Math.abs(delta) > 0.5) requestFrame(update);
      else moving = false;
    }

    var requestFrame = (function () {
      // requestAnimationFrame cross browser
      return (
        window.requestAnimationFrame ||
        // window.webkitRequestAnimationFrame ||
        // window.mozRequestAnimationFrame ||
        // window.oRequestAnimationFrame ||
        // window.msRequestAnimationFrame ||
        function (func) {
          window.setTimeout(func, 1000 / 50);
        }
      );
    })();
  }

  const mediaContainer = document.getElementById("media-container");
  if (mediaContainer) {
    SmoothScroll(mediaContainer, 120, 12);
  }
</script>

<script>
  // MEDIA TRANSFORM______________

  // HELPERS
  const calculateMediaTransform = (
    media: HTMLElement
  ): { scale: number; translate: { x: number; y: number } } => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    const mediaInitialBounds = media.getBoundingClientRect();
    const initialWidth = mediaInitialBounds.width;
    const initialHeight = mediaInitialBounds.height;
    const initialLeft = mediaInitialBounds.left;
    const initialTop = mediaInitialBounds.top;

    const imageOrientation: "landscape" | "portrait" =
      initialWidth > initialHeight ? "landscape" : "portrait";

    const scale: number =
      imageOrientation === "landscape"
        ? (windowWidth * 0.98) / initialWidth
        : (windowHeight * 0.98) / initialHeight;

    const scaledWidth = initialWidth * scale;
    const scaledHeight = initialHeight * scale;

    const scaledYTopChange = (scaledHeight - initialHeight) / 2;
    const scaledYPos = initialTop - scaledYTopChange;
    const yDestination = (windowHeight - scaledHeight) / 2;
    const translateY = yDestination - scaledYPos;

    let translateX: number;

    const imageInitialCenterLeft = initialLeft + initialWidth / 2;
    const pageCenterLeft = windowWidth / 2;
    const transformDirection: "left" | "right" =
      imageInitialCenterLeft < pageCenterLeft ? "right" : "left";
    const leftDestination = (windowWidth - scaledWidth) / 2;

    if (transformDirection === "right") {
      media.style.transformOrigin = "left";
      translateX = leftDestination - initialLeft;
    } else {
      media.style.transformOrigin = "right";
      const scaledWidthChange = scaledWidth - initialWidth;
      const imageLeftAfterScale = initialLeft - scaledWidthChange;
      translateX = leftDestination - imageLeftAfterScale;
    }

    return { scale, translate: { x: translateX, y: translateY } };
  };

  const handleShrinkMediaElement = (
    mediaElement: HTMLElement,
    index: number,
    mediaElementsContainer: HTMLElement,
    mediaElements: HTMLElement[],
    background: HTMLElement,
    expandClass: string
  ) => {
    mediaElement.classList.remove(expandClass);

    mediaElement.style.transform = "translate(0px) scale(1)";

    background.style.opacity = "0";

    const childNodes = Array.from(mediaElement.childNodes).filter(
      (node) => node.nodeName === "DIV"
    ) as HTMLElement[];
    const iframeContainer = childNodes.filter((node) =>
      node.classList.contains("iframe-inner-container")
    )[0];
    const isIframe = Boolean(iframeContainer);

    if (isIframe && iframeContainer) {
      const volMessage = iframeContainer.getElementsByClassName(
        "unmute"
      )[0] as HTMLElement;
      const closeButton = iframeContainer.getElementsByClassName(
        "unmute"
      )[0] as HTMLElement;

      volMessage.style.transform = `scale(0)`;
      closeButton.style.transform = `scale(0)`;
    }

    setTimeout(() => {
      const isLastMediaElement = index === mediaElements.length - 1;
      if (isLastMediaElement) {
        mediaElementsContainer.style.paddingRight = "0px";
      }

      mediaElementsContainer.style.overflowX = "auto";

      mediaElement.style.position = "static";
      mediaElement.style.zIndex = "0";

      for (let j = 0; j < mediaElements.length; j++) {
        const mediaElement = mediaElements[j];
        if (j === index) {
          continue;
        }

        mediaElement.style.opacity = "1";
      }

      background.style.zIndex = "-1";
    }, 550);
  };

  const handleExpandMediaElement = (
    mediaElement: HTMLElement,
    index: number,
    mediaElementsContainer: HTMLElement,
    mediaElements: HTMLElement[],
    background: HTMLElement,
    expandClass: string
  ) => {
    const childNodes = Array.from(mediaElement.childNodes).filter(
      (node) => node.nodeName === "DIV"
    ) as HTMLElement[];
    const iframeContainer = childNodes.filter((node) =>
      node.classList.contains("iframe-inner-container")
    )[0];
    const isIframe = Boolean(iframeContainer);

    if (isIframe) {
      if (!mediaElement.classList.contains("player-ready")) {
        return;
      }
    }

    mediaElement.classList.add(expandClass);

    for (let j = 0; j < mediaElements.length; j++) {
      const image = mediaElements[j];
      if (j === index) {
        continue;
      }

      image.style.opacity = "0";
      image.style.transitionDuration = "100";
    }

    const { scale, translate } = calculateMediaTransform(mediaElement);

    mediaElement.style.zIndex = "3";
    mediaElement.style.left = `${mediaElement.getBoundingClientRect().left}px`;
    mediaElement.style.top = `${mediaElement.getBoundingClientRect().top}px`;
    mediaElement.style.width = `${
      mediaElement.getBoundingClientRect().width
    }px`;
    mediaElement.style.height = `${
      mediaElement.getBoundingClientRect().height
    }px`;

    if (isIframe && iframeContainer) {
      const volMessage = iframeContainer.getElementsByClassName(
        "unmute"
      )[0] as HTMLElement;
      const closeButton = iframeContainer.getElementsByClassName(
        "close-button"
      )[0] as HTMLElement;

      volMessage.style.transform = `scale(${1 / scale})`;
      closeButton.style.transform = `scale(${1 / scale})`;
    }

    const isLastMediaElement = index === mediaElements.length - 1;
    if (isLastMediaElement) {
      const rightOverflow =
        mediaElement.getBoundingClientRect().right - window.innerWidth;

      if (rightOverflow) {
        mediaElementsContainer.style.paddingRight = `${4000}px`;
      }
    }

    // time for other media elements to fade out
    setTimeout(() => {
      mediaElementsContainer.style.overflowX = "visible";
      mediaElement.style.position = "fixed";

      mediaElement.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;

      background.style.zIndex = "2";
      background.style.opacity = "1";
    }, 150);
  };

  const determineIsExpanded = (mediaElement: HTMLElement): boolean =>
    mediaElement.classList.contains(expandClass);

  // ELEMENTS ______________________
  const mediaElementsContainer = document.getElementById(
    "media-container"
  ) as HTMLElement;
  const mediaElements = Array.from(
    document.getElementsByClassName("media") as HTMLCollectionOf<HTMLElement>
  );
  const closeButtons = Array.from(
    document.getElementsByClassName(
      "close-button"
    ) as HTMLCollectionOf<HTMLElement>
  );
  const background = document.getElementById("background") as HTMLElement;

  //
  const expandClass = "expand";

  //
  for (let i = 0; i < mediaElements.length; i++) {
    const mediaElement = mediaElements[i];

    // THIS IS WRONG - should only add close functionality to close button
    mediaElement.addEventListener("click", () => {
      const inInitialPosition = !determineIsExpanded(mediaElement);

      if (inInitialPosition) {
        handleExpandMediaElement(
          mediaElement,
          i,
          mediaElementsContainer,
          mediaElements,
          background,
          expandClass
        );
      } else {
        handleShrinkMediaElement(
          mediaElement,
          i,
          mediaElementsContainer,
          mediaElements,
          background,
          expandClass
        );
      }
    });
  }
</script>

<script type="text/javascript">
  // YOUTUBE IFRAME_________________

  // ELEMENTS
  const mediaElementsContainer = document.getElementById("media-container");
  const iframes = Array.from(document.getElementsByClassName("iframe"));
  const outerContainers = Array.from(
    document.getElementsByClassName("iframe-outer-container")
  );
  const containers = Array.from(
    document.getElementsByClassName("iframe-inner-container")
  );
  const overlays = Array.from(
    document.getElementsByClassName("overlay-container")
  );
  const volMessages = Array.from(document.getElementsByClassName("unmute"));
  const closeButtons = Array.from(
    document.getElementsByClassName("close-button")
  );
  const loadingMessages = Array.from(
    document.getElementsByClassName("player-loading")
  );

  // CONSTANTS
  const volChangedFlag = "vol-changed-programmatically";

  // HELPERS
  function checkIsTouchDevice() {
    return (
      "ontouchstart" in window ||
      navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0
    );
  }

  //
  for (let i = 0; i < iframes.length; i++) {
    const iframe = iframes[i];
    const container = containers[i];
    // const outerContainer = outerContainers[i];

    const containerBounds = container.getBoundingClientRect();

    iframe.height = `${containerBounds.height}`;
    iframe.width = `${(containerBounds.height * 16) / 9}`;
  }

  var tag = document.createElement("script");
  tag.id = "iframe-demo";
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName("script")[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  function onYouTubeIframeAPIReady() {
    for (let i = 0; i < iframes.length; i++) {
      // Elements
      const iframe = iframes[i];
      const outerContainer = outerContainers[i];
      const overlay = overlays[i];
      const volMessage = volMessages[i];
      const closeButton = closeButtons[i];
      const loadingMessage = loadingMessages[i];

      // Helpers
      const showIframeHelperOverlays = () => {
        closeButton.style.opacity = "1";
        closeButton.style.zIndex = "4";
        if (!mediaElementsContainer.classList.contains(volChangedFlag)) {
          volMessage.style.opacity = "1";
          volMessage.style.zIndex = "4";
        }
      };
      const hideIframeHelperOverlays = () => {
        closeButton.style.opacity = "0";
        closeButton.style.zIndex = "-1";
        if (!mediaElementsContainer.classList.contains(volChangedFlag)) {
          volMessage.style.opacity = "0";
          volMessage.style.zIndex = "-1";
        }
      };

      iframe.addEventListener("mouseover", () => {
        showIframeHelperOverlays();
      });
      iframe.addEventListener("mouseleave", () => {
        hideIframeHelperOverlays();
      });
      closeButton.addEventListener("mouseover", () => {
        showIframeHelperOverlays();
      });
      volMessage.addEventListener("mouseover", () => {
        showIframeHelperOverlays();
      });

      const player = new YT.Player(iframe.id, {
        playerVars: { controls: 1 },
        events: {
          onReady: onPlayerReady,
        },
      });

      function onPlayerReady(event) {
        outerContainer.classList.add("player-ready");
        loadingMessage.style.opacity = "0";

        setTimeout(() => {
          loadingMessage.style.zIndex = "-1";
        }, 200);

        overlay.style.cursor = "pointer";
        event.target.setVolume(0);
        overlay.addEventListener("click", () => {
          // time for transform
          setTimeout(() => {
            overlay.style.opacity = "0";
            player.playVideo();
            setTimeout(() => {
              overlay.style.zIndex = "-1";
            }, 200);
          }, 700);
        });

        closeButton.addEventListener("click", () => {
          player.pauseVideo();

          hideIframeHelperOverlays();
          overlay.style.zIndex = "5";
          overlay.style.opacity = "1";
        });

        const iframeWindow = player.getIframe().contentWindow;

        window.addEventListener("message", function (event) {
          if (event.source === iframeWindow) {
            var data = JSON.parse(event.data);

            if (
              data.event === "infoDelivery" &&
              data.info &&
              data.info.volume
            ) {
              if (checkIsTouchDevice()) {
                if (Number(data.info.volume) !== 100) {
                  setTimeout(() => {
                    player.setVolume(100);
                  }, 200);
                }
              }
              if (!mediaElementsContainer.classList.contains(volChangedFlag)) {
                // only want to set to 100 once
                mediaElementsContainer.classList.add(volChangedFlag);
                volMessage.style.opacity = 0;
                volMessage.style.zIndex = "-1";
              }
            }
          }
        });
      }
    }
  }
</script>

<script type="text/javascript">
  window.addEventListener("orientationchange", () => {
    location.reload();
  });
</script>

<script>
  const images = document.getElementsByClassName(
    "original-size-img"
  ) as HTMLCollectionOf<HTMLElement>;
  for (let i = 0; i < images.length; i++) {
    const image = images[i];
    image.style.width = "";
  }
</script>

<script>
  // Handle position since not working with `Picture` component
  // could have done below with a wrapping div and style prop
  const images = document.getElementsByClassName(
    "iframe-img"
  ) as HTMLCollectionOf<HTMLElement>;
  for (let i = 0; i < images.length; i++) {
    const image = images[i];
    const objPos = getComputedStyle(image).objectPosition;
    const regexMatches = objPos.match(/\d+(?=\%)/g);
    if (regexMatches) {
      const yPos = regexMatches[1];
      image.style.transform = `translateY(-${yPos}%)`;
    }
  }
</script>

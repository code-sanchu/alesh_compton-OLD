---
import { Image } from "@astrojs/image/components";

import MediaContainer from "~components/media/Container.astro";
import Background from "~components/media/Background.astro";
import YoutubeIframe from "~components/video/YoutubeIframe.astro";

import type { LocalImage, YoutubeVideo } from "~types/index";

type Props = { media: (LocalImage | YoutubeVideo)[] };

const { media } = Astro.props;

// vol, close butt positioning; iframe max width as width - timeout width;

// TODO: undo iframe-inner container transform on contract animation; can't click on iframe overlay again after contract.
// TODO close: clicking on bg closes. what happens if youtube player loading and exit transformation.
// TODO: vol text, should probably just contain by default (not just on touch devices - to account for resize browser)

// NOTES
// - only point of the duplication is to keep the width of the container when image content translated
// - seems like the hidden images won't be loaded

// CHECK
// iframe is scaled correctly. Check transform origin to counteract translate works across all devices, etc; position iframe moves from.
// can click on close iframe if iframe takes up whole screen (on touch screen)?
---

<MediaContainer>
  <div class="media-inner">
    {
      media.map((mediaElement) =>
        mediaElement.type === "image" ? (
          <Image
            class="image-img-duplicate duplicate"
            src={mediaElement.url}
            alt=""
            format="avif"
          />
        ) : (
          <div class="iframe-duplicate duplicate" />
        )
      )
    }
    <div class="spacer">helloo</div>
    <div class="visible-media" id="visible-media">
      {
        media.map((mediaElement, index) =>
          mediaElement.type === "image" ? (
            <Image
              class="image-img media-transform"
              src={mediaElement.url}
              alt=""
              loading={index === 0 ? "eager" : "lazy"}
              fit="contain"
              format="avif"
              id={`${index}`}
            />
          ) : (
            <YoutubeIframe
              {...mediaElement}
              isFirst={index === 0}
              index={index}
            />
          )
        )
      }
      <div class="spacer">helloo</div>
      <Background />
    </div>
  </div>
</MediaContainer>

<style is:global>
  .media-transform {
    cursor: pointer;
    opacity: 0;
    transition: opacity ease-in 0.3s, transform ease-in-out, width ease-in-out,
      height ease-in-out, margin ease-in-out;
  }
</style>

<style>
  .media-inner {
    position: relative;
    display: flex;
    align-items: flex-start;
    gap: 1vw;
    height: 100%;
  }
  .spacer {
    color: white;
  }
  .visible-media {
    z-index: 3;
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: flex-start;
    gap: 1vw;
    background: white;
  }
  .image-img,
  .image-img-duplicate {
    max-height: 100%;
    object-fit: contain;
  }
  .iframe-duplicate {
    height: 100%;
    max-height: 1000px;
    aspect-ratio: 16 / 9;
  }
  .duplicate {
    visibility: hidden;
  }
  @media screen and (max-width: 900px) {
    .image-img,
    .image-img-duplicate {
      width: auto;
    }
  }
</style>

<script>
  // FADE IN MEDIA (hacky but should be okay since images are local and so will load in quick)
  // _________________________________

  const mediaContainer = document.getElementById("media-container")!;
  const media = mediaContainer.getElementsByClassName(
    "media-transform"
  ) as HTMLCollectionOf<HTMLElement>;

  // avoid image flashing in
  for (let i = 0; i < media.length; i++) {
    const mediaElement = media[i];
    mediaElement.style.opacity = "1";
  }
</script>

<script>
  // MEDIA TRANSFORM
  // _________________________________
  const isTransformingOutClass = "is-transforming-out";
  const isTransformedOutClass = "is-transformed-out";
  const isTransformingInClass = "is-transforming-in";

  function checkIsTransformingOut(element: HTMLElement) {
    return element.classList.contains(isTransformingOutClass);
  }
  function checkIsTransformedOut(element: HTMLElement) {
    return element.classList.contains(isTransformedOutClass);
  }
  function checkIsTransformingIn(element: HTMLElement) {
    return element.classList.contains(isTransformingInClass);
  }

  //
  function checkIsTouchDevice() {
    return (
      "ontouchstart" in window ||
      navigator.maxTouchPoints > 0 ||
      // @ts-ignore: Unreachable code error
      navigator.msMaxTouchPoints > 0
    );
  }

  function getContainedSize(img: HTMLImageElement) {
    var ratio = img.naturalWidth / img.naturalHeight;
    var width = img.height * ratio;
    var height = img.height;
    if (width > img.width) {
      width = img.width;
      height = img.width / ratio;
    }
    return [width, height];
  }

  //
  function getTransitionDurationMs(element: HTMLElement) {
    return parseFloat(getComputedStyle(element).transitionDuration) * 1000;
  }

  function isIframeTransformContainer(element: HTMLElement) {
    return element.classList.contains("iframe-container");
  }

  //
  function fixElementPosition(element: HTMLElement) {
    const rect = element.getBoundingClientRect();

    element.style.left = `${rect.left}px`;
    element.style.top = `${rect.top}px`;
    element.style.width = `${rect.width}px`;
    element.style.height = `${rect.height}px`;

    element.style.position = "fixed";
  }

  function revertIframeToInitialPlacement(element: HTMLElement) {
    element.style.zIndex = "0";

    element.style.transform = "";
    element.style.left = "0";
    element.style.top = "0";

    element.style.maxHeight = "1000px";
    element.style.height = "100%";
    element.style.width = "";
    element.style.marginTop = "0";
    element.style.marginLeft = "0";
    element.style.position = "relative";
  }
  function revertImageToInitialPlacement(element: HTMLElement) {
    element.style.zIndex = "0";

    element.style.transform = "";
    element.style.left = "0";
    element.style.top = "0";

    element.style.width = "";
    element.style.height = "";
    element.style.position = "static";
  }

  type Mutable<T> = {
    -readonly [k in keyof T]: T[k];
  };
  type CustomRect = Mutable<{
    width: number;
    height: number;
    left: number;
    top: number;
  }>;

  function calcFillScreenRect(element: HTMLElement) {
    const elementRect = element.getBoundingClientRect();

    const maxWidth = window.innerWidth * 0.98;
    const maxHeight = window.innerHeight * 0.98;

    const fillWidthHeight = elementRect.height * (maxWidth / elementRect.width);

    if (fillWidthHeight <= maxHeight) {
      const width = maxWidth;
      const height = fillWidthHeight;
      const left = (window.innerWidth - width) / 2;
      const top = (window.innerHeight - height) / 2;
      return {
        width,
        height,
        left,
        top,
      } as CustomRect;
    }

    const width = elementRect.width * (maxHeight / elementRect.height);
    const height = maxHeight;
    const left = (window.innerWidth - width) / 2;
    const top = (window.innerHeight - height) / 2;

    return {
      width,
      height,
      left,
      top,
    } as CustomRect;
  }

  function calcElementTransform({
    destinationRect,
    element,
  }: {
    element: HTMLElement;
    destinationRect: CustomRect;
  }) {
    // destination rect has same aspect-ratio as elementRect

    const initialRect = element.getBoundingClientRect();

    const scale = destinationRect.width / initialRect.width;

    const heightChangeFromScale =
      initialRect.height * scale - initialRect.height;
    const topChangeFromScale = heightChangeFromScale / 2;
    // must minus to go up for 'top'
    const topAfterScale = initialRect.top - topChangeFromScale;
    const translateY = destinationRect.top - topAfterScale;

    let translateX: number;
    const transformDirection =
      destinationRect.left < initialRect.left ? "left" : "right";

    if (transformDirection === "left") {
      const widthChangeFromScale =
        initialRect.width * scale - initialRect.width;
      const leftAfterScale = initialRect.left - widthChangeFromScale;
      translateX = destinationRect.left - leftAfterScale;
    } else {
      translateX = destinationRect.left - initialRect.left;
    }

    const totalX = Math.abs(initialRect.left - destinationRect.left);
    const totalY = Math.abs(initialRect.top - destinationRect.top);
    const translateDistance = Math.sqrt(
      Math.pow(totalX, 2) + Math.pow(totalY, 2)
    );

    return {
      scale,
      translateX,
      translateY,
      transformOrigin: transformDirection === "left" ? "right" : "left",
      translateDistance,
      width: destinationRect.width,
      height: destinationRect.height,
      marginTop: destinationRect.top - initialRect.top,
      marginLeft: destinationRect.left - initialRect.left,
    };
  }

  //
  function transform({
    transformingElement,
    destinationRect,
    transformBy,
  }: {
    transformingElement: HTMLElement;
    destinationRect: CustomRect;
    transformBy: "width-height-margin" | "scale-translate";
  }) {
    const {
      scale,
      transformOrigin,
      translateDistance,
      translateX,
      translateY,
      width,
      height,
      marginLeft,
      marginTop,
    } = calcElementTransform({
      destinationRect,
      element: transformingElement,
    });

    const transitionDuration = 300 + Math.sqrt(translateDistance) * 15;

    transformingElement.style.transitionDuration = `${transitionDuration}ms`;

    if (transformBy === "width-height-margin") {
      transformingElement.style.width = `${width}px`;
      transformingElement.style.height = `${height}px`;
      transformingElement.style.marginTop = `${marginTop}px`;
      transformingElement.style.marginLeft = `${marginLeft}px`;
      return;
    }

    transformingElement.style.transformOrigin = `${transformOrigin}`;
    transformingElement.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  //
  function showBackground() {
    const background = document.getElementById("background")!;
    background.style.position = "fixed";
    background.style.zIndex = "5";
    background.style.opacity = "1";
  }

  //
  const mediaContainer = document.getElementById("media-container")!;
  const transformElements = Array.from(
    mediaContainer.getElementsByClassName(
      "media-transform"
    ) as HTMLCollectionOf<HTMLElement>
  );
  const duplicates = Array.from(
    mediaContainer.getElementsByClassName(
      "duplicate"
    ) as HTMLCollectionOf<HTMLElement>
  );

  //
  transformElements.forEach((transformElement, index) => {
    transformElement.addEventListener("click", () => {
      const isInInitialPosition = !checkIsTransformingOut(transformElement);
      const isTransformedOut = checkIsTransformedOut(transformElement);
      const isTransformingIn = checkIsTransformingIn(transformElement);

      if (isInInitialPosition && !isTransformedOut && !isTransformingIn) {
        // TRANSFORM OUT: START
        console.log("TRANSFORMING OUT");
        transformElement.classList.add(isTransformingOutClass);
        transformElement.style.pointerEvents = "none";

        for (let j = transformElements.length - 1; j >= index; j--) {
          fixElementPosition(transformElements[j]);
        }

        transformElement.style.zIndex = "10";

        const fillScreenRect = calcFillScreenRect(transformElement);
        const isIframe = isIframeTransformContainer(transformElement);

        transform({
          destinationRect: fillScreenRect,
          transformBy: isIframe ? "width-height-margin" : "scale-translate",
          transformingElement: transformElement,
        });

        showBackground();

        // time for bg to show
        setTimeout(() => {
          // prevent scrolling
          mediaContainer.style.overflowX = "hidden";
        }, 200);

        const transitionDuration = getTransitionDurationMs(transformElement);

        // timeout until transform transition end
        setTimeout(() => {
          // orientation + resize considerations: start

          transformElement.style.transitionDuration = "0ms";

          if (isIframe) {
            transformElement.style.marginTop = "0";
            transformElement.style.marginLeft = "0";

            const deviceBiggestSide =
              window.innerWidth > window.innerHeight
                ? window.innerWidth
                : window.innerHeight;

            transformElement.style.maxWidth = `${deviceBiggestSide * 0.8}px`;
            transformElement.style.maxHeight = "100vh";

            //
            const innerContainer = transformElement.getElementsByClassName(
              "inner-container"
            )[0] as HTMLElement;

            innerContainer.style.left = "50%";
            innerContainer.style.top = "50%";
            innerContainer.style.transform = "translate(-50%, -50%)";

            const iframeOverlay = transformElement.getElementsByClassName(
              "iframe-overlay"
            )[0] as HTMLElement;
            iframeOverlay.style.left = "50%";
            iframeOverlay.style.top = "50%";
            iframeOverlay.style.transform = "translate(-50%, -50%)";
          }

          transformElement.style.width = `98%`;
          transformElement.style.height = `98%`;
          transformElement.style.left = `50%`;
          transformElement.style.top = `50%`;
          transformElement.style.transform = "translate(-50%, -50%)";

          // orientation + resize considerations: end

          transformElement.style.pointerEvents = "auto";
          transformElement.classList.add(isTransformedOutClass);
        }, transitionDuration);

        // TRANSFORM OUT: END
      } else {
        const isIframe = isIframeTransformContainer(transformElement);
        if (isIframe) {
          // iframe handled by close button click listener
          return;
        }
        // RETURN TO INITIAL POSITION: start

        transformElement.classList.remove(isTransformingOutClass);
        transformElement.classList.remove(isTransformedOutClass);

        transformElement.style.pointerEvents = "none";

        transformElement.style.transitionDuration = "0ms";

        const [width, height] = getContainedSize(
          transformElement as HTMLImageElement
        );

        transformElement.style.left = `${(window.innerWidth - width) / 2}px`;
        transformElement.style.top = `${(window.innerHeight - height) / 2}px`;
        transformElement.style.width = `${width}px`;
        transformElement.style.height = `${height}px`;

        transformElement.style.position = "fixed";

        transformElement.style.transform = "";

        const duplicate = duplicates[index];
        const duplicateRect = duplicate.getBoundingClientRect();

        transform({
          destinationRect: duplicateRect,
          transformBy: "scale-translate",
          transformingElement: transformElement,
        });

        const transitionDuration = getTransitionDurationMs(transformElement);

        setTimeout(() => {
          mediaContainer.style.overflowX = "auto";
        }, transitionDuration - 300);

        // revert to initial, untransformed css
        setTimeout(() => {
          transformElement.style.transitionDuration = "0ms";

          revertImageToInitialPlacement(transformElement);

          for (let j = transformElements.length - 1; j > index; j--) {
            const transformElement = transformElements[j];
            const isIframe = isIframeTransformContainer(transformElement);

            if (isIframe) {
              revertIframeToInitialPlacement(transformElement);
            } else {
              revertImageToInitialPlacement(transformElement);
            }
          }

          transformElement.style.pointerEvents = "auto";
        }, transitionDuration);

        const background = document.getElementById("background")!;
        background.style.opacity = "0";
        setTimeout(() => {
          background.style.zIndex = "-1";
          background.style.position = "static";
        }, transitionDuration);

        // RETURN TO INITIAL POSITON: END
      }
    });
  });

  const closeButtons = Array.from(
    mediaContainer.getElementsByClassName(
      "close-button"
    ) as HTMLCollectionOf<HTMLElement>
  );
  const iframeTransformContainers = Array.from(
    mediaContainer.getElementsByClassName("iframe-container media-transform")
  );
  const iframes = Array.from(
    mediaContainer.getElementsByClassName(
      "iframe"
    ) as HTMLCollectionOf<HTMLElement>
  );
  const overlays = Array.from(
    mediaContainer.getElementsByClassName(
      "iframe-overlay"
    ) as HTMLCollectionOf<HTMLElement>
  );
  const volumeMessages = Array.from(
    mediaContainer.getElementsByClassName(
      "volume-message"
    ) as HTMLCollectionOf<HTMLElement>
  );

  closeButtons.forEach((closeButton, iframeIndex) => {
    const transformElement = iframeTransformContainers[
      iframeIndex
    ] as HTMLElement;

    closeButton.addEventListener("click", () => {
      const isExpanded = transformElement.classList.contains(
        isTransformedOutClass
      );

      if (!isExpanded) {
        return;
      }
      // RETURN TO INITIAL POSITION: start
      transformElement.classList.add(isTransformingInClass);

      transformElement.classList.remove(isTransformingOutClass);
      transformElement.classList.remove(isTransformedOutClass);

      transformElement.style.pointerEvents = "none";
      //
      const overlay = overlays[iframeIndex];
      const volumeMessage = volumeMessages[iframeIndex];

      overlay.style.zIndex = "2";
      overlay.style.opacity = "1";

      closeButton.style.opacity = "0";
      volumeMessage.style.opacity = "0";

      setTimeout(() => {
        closeButton.style.zIndex = "-1";
        volumeMessage.style.zIndex = "-1";
      }, 200);

      const iframe = iframes[iframeIndex];
      // @ts-ignore: Unreachable code error
      const player = window[`player${iframe.id}`];

      if (player) {
        player.pauseVideo();
      }

      // time for overlay
      setTimeout(() => {
        const allElementsIndex = Number(transformElement.id);

        transformElement.style.transitionDuration = "0ms";
        fixElementPosition(transformElement);
        transformElement.style.transform = "";
        transformElement.style.maxWidth = "";

        const duplicate = duplicates[allElementsIndex];
        const duplicateRect = duplicate.getBoundingClientRect();

        transform({
          destinationRect: duplicateRect,
          transformBy: "width-height-margin",
          transformingElement: transformElement,
        });

        const transitionDuration = getTransitionDurationMs(transformElement);

        setTimeout(() => {
          mediaContainer.style.overflowX = "auto";
        }, transitionDuration / 2);

        // revert to initial, untransformed css
        setTimeout(() => {
          transformElement.style.transitionDuration = "0ms";

          revertIframeToInitialPlacement(transformElement);

          for (
            let j = transformElements.length - 1;
            j > allElementsIndex;
            j--
          ) {
            const transformElement = transformElements[j];
            const isIframe = isIframeTransformContainer(transformElement);

            if (isIframe) {
              revertIframeToInitialPlacement(transformElement);
            } else {
              revertImageToInitialPlacement(transformElement);
            }
          }

          transformElement.style.pointerEvents = "auto";
        }, transitionDuration);

        const background = document.getElementById("background")!;
        background.style.opacity = "0";
        setTimeout(() => {
          background.style.zIndex = "-1";
          background.style.position = "static";
        }, transitionDuration);
      }, 100);

      // RETURN TO INITIAL POSITON: END
    });
  });
</script>

<script type="text/javascript">
  // YOUTUBE STUFF
  function main() {
    //
    class ClassWatcher {
      constructor(
        targetNode,
        classToWatch,
        classAddedCallback,
        classRemovedCallback
      ) {
        this.targetNode = targetNode;
        this.classToWatch = classToWatch;
        this.classAddedCallback = classAddedCallback;
        this.classRemovedCallback = classRemovedCallback;
        this.observer = null;
        this.lastClassState = targetNode.classList.contains(this.classToWatch);

        this.init();
      }

      init() {
        this.observer = new MutationObserver(this.mutationCallback);
        this.observe();
      }

      observe() {
        this.observer.observe(this.targetNode, { attributes: true });
      }

      disconnect() {
        this.observer.disconnect();
      }

      mutationCallback = (mutationsList) => {
        for (let mutation of mutationsList) {
          if (
            mutation.type === "attributes" &&
            mutation.attributeName === "class"
          ) {
            let currentClassState = mutation.target.classList.contains(
              this.classToWatch
            );
            if (this.lastClassState !== currentClassState) {
              this.lastClassState = currentClassState;
              if (currentClassState) {
                this.classAddedCallback();
              } else {
                if (this.classRemovedCallback) {
                  this.classRemovedCallback();
                }
              }
            }
          }
        }
      };
    }

    //
    function onYoutubePlayerReady(playerId) {}

    //
    function handleLoadYoutubeApiCode() {
      var tag = document.createElement("script");
      tag.id = "iframe-demo";
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName("script")[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }

    //
    const isTransformedOutClass = "is-transformed-out";

    const iframeTransformContainers = Array.from(
      document.getElementsByClassName("iframe-container media-transform")
    );
    const iframes = document.getElementsByClassName("iframe");
    const overlays = document.getElementsByClassName("iframe-overlay");
    const helperPanels = document.getElementsByClassName("iframe-helper");

    //
    function onIsTransformedOut({
      iframe,
      overlay,
      transformContainer,
      iframeIndex,
    }) {
      if (!transformContainer.classList.contains(isTransformedOutClass)) {
        return;
      }
      const youtubeApiCodeInitiatedClass = "yt-api-code-loading";
      const youtubeApiReadyFlag = "yt-api-ready";

      const mediaContainer = document.getElementById("media-container");
      const loadingText = Array.from(
        document.getElementsByClassName("player-loading")
      )[iframeIndex];

      //
      const youtubeApiIsInitiated = mediaContainer.classList.contains(
        youtubeApiCodeInitiatedClass
      );
      const youtubeApiIsReady =
        mediaContainer.classList.contains(youtubeApiReadyFlag);

      //
      function showLoading() {
        loadingText.style.zIndex = "10";
        loadingText.style.opacity = "1";
      }

      if (!youtubeApiIsInitiated || !youtubeApiIsReady) {
        showLoading();
      }

      if (!youtubeApiIsInitiated) {
        mediaContainer.classList.add(youtubeApiCodeInitiatedClass);
        handleLoadYoutubeApiCode();
        return;
      }

      if (!youtubeApiIsReady) {
        return;
      }
      if (iframe.classList.contains("yt-player-loading")) {
        return;
      }

      const player = window[`player${iframe.id}`];

      if (player) {
        overlay.style.opacity = "0";

        const helperPanel = helperPanels[iframeIndex];

        helperPanel.style.zIndex = "10";
        helperPanel.style.opacity = "1";
        // time for opacity transition
        setTimeout(() => {
          overlay.style.zIndex = "-1";

          window[iframe.id].playVideo();
        }, 200);

        return;
      }

      showLoading();

      window[iframe.id] = new YT.Player(iframe.id, {
        events: {
          onReady,
        },
      });

      function onReady(event) {
        loadingText.style.opacity = "0";
        setTimeout(() => {
          loadingText.style.zIndex = "-1";
        }, 200);

        event.target.setVolume(0);

        overlay.style.opacity = "0";

        const helperPanel = helperPanels[iframeIndex];

        helperPanel.style.zIndex = "10";
        helperPanel.style.opacity = "1";
        // time for opacity transition
        setTimeout(() => {
          overlay.style.zIndex = "-1";

          event.target.playVideo();
        }, 200);
      }
    }

    iframeTransformContainers.forEach((transformContainer, i) => {
      new ClassWatcher(transformContainer, isTransformedOutClass, () =>
        onIsTransformedOut({
          iframe: iframes[i],
          overlay: overlays[i],
          transformContainer,
          iframeIndex: i,
        })
      );
    });
  }
  main();

  // The API will call this function when the page has finished downloading the JavaScript for the player API, which enables you to then use the API on your page.
  // the API's js is loaded after the first iframe container is transformed
  function onYouTubeIframeAPIReady() {
    const youtubeApiReadyFlag = "yt-api-ready";
    const mediaContainer = document.getElementById("media-container");

    mediaContainer.classList.add(youtubeApiReadyFlag);

    const iframeTransformContainers = Array.from(
      document.getElementsByClassName("iframe-container media-transform")
    );

    const helperPanels = document.getElementsByClassName("iframe-helper");

    const isTransformedOutClass = "is-transformed-out";

    const index = iframeTransformContainers.findIndex((node) =>
      node.classList.contains(isTransformedOutClass)
    );

    if (index < 0) {
      return;
    }

    const iframes = Array.from(document.getElementsByClassName("iframe"));
    const iframe = iframes[index];

    iframe.classList.add("yt-player-loading");

    window[`player${iframe.id}`] = new YT.Player(iframe.id, {
      events: {
        onReady,
      },
    });

    function onReady(event) {
      event.target.setVolume(0);

      const overlay = Array.from(
        document.getElementsByClassName("iframe-overlay")
      )[index];

      overlay.style.opacity = "0";

      const helperPanel = helperPanels[index];

      helperPanel.style.zIndex = "10";
      helperPanel.style.opacity = "1";

      // time for opacity transition
      setTimeout(() => {
        overlay.style.zIndex = "-1";

        event.target.playVideo();

        iframe.classList.remove("yt-player-loading");
      }, 200);
    }
  }
</script>

---
import { Image } from "@astrojs/image/components";

type Props = { srcs: string[] };

const { srcs } = Astro.props;
// TODO: landscape image
---

{srcs.map((src) => <Image class="image" src={src} alt="" format="avif" />)}
<div id="background" class="background"></div>

<style>
  img {
    width: auto;
    max-height: 100%;
    cursor: pointer;
    transition: transform ease-in-out 0.5s;
  }
  .expand {
    /* z-index: 2; */
    /* position: fixed; */
    /* left: 0; */
    /* top: 0; */
    /* width: 90%; */
    /* height: 90%; */
    /* object-fit: contain; */
  }
  .background {
    z-index: -1;
    /* background-color: rgba(244, 245, 246, 0.3); */
    position: fixed;
    inset: 0;
    background-color: #ffffff;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23000000' fill-opacity='1' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
    transition: opacity ease-in-out 0.5s;
    opacity: 0;
  }
</style>

<script>
  const images = Array.from(
    document.getElementsByClassName(
      "image"
    ) as HTMLCollectionOf<HTMLImageElement>
  );
  const background = document.getElementById("background");

  // TODO: update other images too to stay fixed
  // - image jumps at beginning and end of contraction
  for (let i = 0; i < images.length; i++) {
    const image = images[i];

    if (image && background) {
      image.addEventListener("click", () => {
        const classList = image.classList;
        const expandClass = "expand";
        const isExpanded = classList.contains(expandClass);
        if (isExpanded) {
          image.classList.remove(expandClass);

          image.style.transform = "translate(0px) scale(1)";

          for (let j = 0; j < images.length; j++) {
            const image = images[j];
            if (j === i) {
              continue;
            }

            image.style.position = "static";
          }

          setTimeout(() => {
            if (image.parentElement) {
              image.parentElement.style.overflowX = "auto";
            }
            image.style.position = "static";
            image.style.zIndex = "0";
          }, 550);

          background.style.opacity = "0";
          setTimeout(() => {
            background.style.zIndex = "-1";
          }, 550);
        } else {
          image.classList.add(expandClass);

          const pageWidth = document.body.scrollWidth;
          const pageHeight = document.body.scrollHeight; // 1660

          const initialImageWidth = image.getBoundingClientRect().width;
          const imageHeight = image.getBoundingClientRect().height; // 1084

          const initialImageLeft = image.getBoundingClientRect().left;

          const imageOrientation =
            initialImageWidth > imageHeight
              ? "landscape"
              : ("portrait" as const);

          let scale: number;

          let translateY: number;
          let translateX: number;

          if (imageOrientation === "landscape") {
            const maxWidth = pageWidth * 0.9;
            scale = maxWidth / initialImageWidth;

            translateX = -100;
            translateY = -100;

            const xDestination = pageWidth - maxWidth;
            const yDestination = (pageHeight - imageHeight * scale) / 2;
          } else {
            const maxHeight = pageHeight * 0.9;
            scale = maxHeight / imageHeight;

            const scaledWidth = initialImageWidth * scale;
            const newHeight = imageHeight * scale;

            const initialYTop = image.getBoundingClientRect().top;
            const scaledYTopChange = (newHeight - imageHeight) / 2;
            const scaledYPos = initialYTop - scaledYTopChange;
            const yDestination = (pageHeight - newHeight) / 2;
            translateY = yDestination - scaledYPos;

            const imageInitialCenterLeft =
              initialImageLeft + initialImageWidth / 2;
            const pageCenterLeft = pageWidth / 2;
            const transformDirection: "left" | "right" =
              imageInitialCenterLeft < pageCenterLeft ? "right" : "left";

            const leftDestination = (pageWidth - scaledWidth) / 2;

            if (transformDirection === "right") {
              image.style.transformOrigin = "left";
              translateX = leftDestination - initialImageLeft;
            } else {
              image.style.transformOrigin = "right";
              const scaledWidthChange = scaledWidth - initialImageWidth;
              const imageLeftAfterScale = initialImageLeft - scaledWidthChange;
              translateX = leftDestination - imageLeftAfterScale;
            }
          }

          if (image.parentElement) {
            image.parentElement.style.overflowX = "visible";
          }

          // image.style.display = "absolute";
          image.style.zIndex = "3";
          image.style.left = `${initialImageLeft}px`;
          image.style.top = `${image.getBoundingClientRect().top}px`;

          for (let j = 0; j < images.length; j++) {
            const image = images[j];
            if (j === i) {
              continue;
            }

            image.style.zIndex = "2";
            image.style.left = `${image.getBoundingClientRect().left}px`;
            image.style.top = `${image.getBoundingClientRect().top}px`;
            image.style.position = "fixed";
          }

          image.style.position = "fixed";
          image.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

          background.style.opacity = "1";
          background.style.zIndex = "1";
        }
      });
    }
  }
</script>
